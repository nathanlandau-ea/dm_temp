<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exemple de situation réelle</title>
</head>
<body>
    <h1>Exemple de situation réelle</h1>
    <details>
        <summary>Présentation de la situation presque réelle</summary>
        <p>
            Un pays cherche à relier ses villes par des autoroutes. Cependant, l'État manque d’argent. Il faut donc trouver un moyen pour qu’il soit toujours possible d’aller d’une ville à une autre en prenant uniquement l’autoroute, tout en minimisant le coût de l’infrastructure. On connaît toujours le prix supposé de la route entre deux villes.
        </p>
    </details>
    <details>
        <summary>Représentation en termes de graphe du problème</summary>
        <p>
            On peut représenter les villes par des sommets et les routes par des arêtes dont le poids est le prix de la route. La solution est donc de trouver un MST (arbre couvrant minimum). C’est un arbre, donc c’est un ensemble d’arêtes ne contenant aucun cycle, et reliant n’importe quelle paire de sommets par un chemin. Par exemple, on peut facilement voir que s’il y a un cycle, il existe plusieurs chemins possibles pour aller d’un sommet à un autre, ce qui est redondant, si on veut payer le moins possible. Ensuite, couvrant signifie simplement que l’arbre passe par tous les sommets du graphe. Et finalement, minimum signifie que si on fait la somme des poids des arêtes, on ne peut pas trouver d’autre arbre avec une somme des poids inférieurs.
        </p>
    </details>
    <details>
        <summary>l’algorithme de Kruskal</summary>
        <p>
            On prend simplement l'arête avec un poids minimum et si en la rajoutant on ne forme pas de cycle on la garde. Pour savoir si une arête crée un cycle, on peut vérifier qu’il n’existe pas déjà un chemin entre les deux villes reliés par l’arête, et pour cela on peut utiliser un algorithme appelé Union-Find. Le principe est simple : on assigne à chaque ville un parent, et si deux villes sont de la même famille, elles sont déjà reliées. On commence en se disant que chaque ville n’a pas de parent. Quand on rajoute une arête entre les sommets A et B, on décide que l’ancêtre de B devient le parent de l’ancêtre de A.
        </p>
        <code>
            nb_villes = 7<br>
            autoroutes_possibles = [(0, 1, 7), (0, 2, 4), (0, 3, 2), (0, 5, 1), (0, 6, 4), (1, 3, 9), (1, 4, 3), (2, 5, 9), (3, 4, 1), (3, 6, 8), (4, 5, 2), (4, 6, 3)]<br>
            <br>
            # les autoroutes possibles sont représentées <br>
            # comme un tuple (ville1, ville2, coût)<br>
            # on doit d'abord trier les routes par coût<br>
            <br>
            def cout(autoroute):<br>
                return autoroute[2]<br>
            <br>
            autoroutes_possibles.sort(key = cout)<br>
            <br>
            <br>
            # on définit les parents de chaque ville à -1 (qui correspond à indéfini)<br>
            parents = [-1]*nb_villes<br>
            <br>
            # on définit la fonction pour trouver l'ancêtre d'une ville<br>
            def ancetre(ville):<br>
                # si une ville n'a pas de parent, c'est elle l'ancêtre<br>
                if parents[ville] == -1:<br>
                    return ville<br>
                # sinon son ancêtre est le même que celui de son parent<br>
                # donc on peut redéfinir son parent pour être l'ancêtre de son ancien parent<br>
                parents[ville] = ancetre(parents[ville])<br>
                return parents[ville]<br>
            <br>
            # on définit la fonction pour vérifier si <br>
            # deux villes sont déjà reliées<br>
            def deja_reliees(ville1, ville2):<br>
                return ancetre(ville1) == ancetre(ville2)<br>
            <br>
            # on définit la fonction pour relier deux villes<br>
            def relier(ville1, ville2):<br>
                parents[ancetre(ville1)] = ancetre(ville2)<br>
            <br>
            prix_total = 0<br>
            nb_autoroutes_ajoutees = 0<br>
            # on effectue l'algorithme de Kruskal<br>
            for autoroute in autoroutes_possibles:<br>
                if not deja_reliees(autoroute[0], autoroute[1]):<br>
                    prix_total += autoroute[2]<br>
                    relier(autoroute[0], autoroute[1])<br>
                    nb_autoroutes_ajoutees += 1<br>
                # par définition un arbre contient nb_sommets-1 arêtes<br>
                if nb_autoroutes_ajoutees == nb_villes - 1:<br>
                    break<br>
            <br>
            print(prix_total)
        </code>
    </details>
</body>
</html>